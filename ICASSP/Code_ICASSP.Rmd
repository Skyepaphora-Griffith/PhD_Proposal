
```{r}
## --- Packages 
library(multitaper)   
library(pbapply)      # Progress bar for apply() functions
library(kableExtra)   
library(itsmr)        # Time series stuff, convenient for ARMA
library(animation)    # For creating gifs
library(fields)       # Supplement for image plots: legends, better colour
```

```{r}
load("PaperData/UMP_B200_full.RData")

# save.image(paste0("PaperData/",my.type,"_B",B,"_full.RData"))
# save.image(paste0("PaperData/",my.type,"_B",B,"_full_S.RData"))
```

# GEST 

### Azadeh

```{r}
# --- Create Function for getting Azadeh's g (and sy)
est.a <- function(sgram, est = "g"){
  # SVD
  duv <- svd(sgram,1,1); gc()
  
  d <- duv$d
  u <- duv$u
  v <- duv$v
  
  # Normalize
  bu <- 1/duv$u[1]
  bv <- duv$d[1]/bu
  
  # Estimate g
  g <- bu * duv$u
  
  # Estimate Sy
  sy <- bv * duv$v
  
  # Re-normalize (optional)
  # g  <- g /max(abs(g ))
  # sy <- sy/max(abs(sy))
  
  # Return
  return(if(est == "g"){g} else {sy})
}

# normalizing function
normy <- function(x){x/max(abs(x))}
```

```{r}
# ALL results
ag.full <- pbapply(trial$cbc, 3, est.a); gc()

# Normalized Average
ag  <- -normy(rowMeans(ag.full))
```

### Skye

```{r}
gest <- function(sgram, normalize = FALSE){
  N <- length(sgram[,1])
  A <- outer(1:N,1:N, function(l,j){rowSums(sgram)[l]/rowSums(sgram)[j]})
  G <- Mod(eigen(A/N)$vectors[,1])
  if(normalize){G <- G/max(G)}
  return(G); gc()
}
```

```{r}
# FULL --- (warning: long-ish runtime)
sg.full <- pbapply(trial$cbc,3, gest); gc()

# Normalized Average
sg <- normy(rowMeans(sg.full))
```

# YEST

### Azadeh

```{r}
# ALL results
ayf.full <- pbapply(trial$cbc, 3, function(x){est.a(x, est = "sy")}); gc()

# Normalized Average
ayf <- -normy(rowMeans(ayf.full))
```

### Skye

```{r}
yest <- function(sgram, normalize = FALSE){
  N <- length(sgram[1,])
  A <- outer(1:NF,1:NF, function(l,j){colSums(sgram)[l]/colSums(sgram)[j]})
  S <- Mod(eigen(A/NF)$vectors[,1])
  if(normalize){S <- S/max(S)}
  return(S); gc()
}
```

```{r}
# FULL --- (warning: long-ish runtime)
syf.full <- pbapply(trial$cbc,3, yest); gc()

# Normalized Average
syf <- normy(rowMeans(syf.full))
```


# Smooth Sgrams

```{r}
smoo <- function(g, yf){
  
  n  <- length( g[,1])
  nf <- length(yf[,1])
  m  <- length( g[1,])
  
  out <- array(0,c(n,nf,m))
  
  for(s in 1:m){
    out[,,s] <- outer(g[,m],yf[,m])
  }
  gc()
  return(out)
}
```

```{r}
asx.full <- smoo(ag.full, ayf.full)
asx <- pbapply( asx.full, 1:2, mean)

ssx.full <- smoo(sg.full, syf.full)
ssx <- pbapply( ssx.full, 1:2, mean)

gc()
```


### Single instance

```{r}
# Roll the 100-sided die
set.seed(69)
samp <- sample(1:M, 1)

# Choose realizations, get corresponding g
cbc.samp <- trial$cbc[,,samp]
g.samp   <-  sg.full[,samp]
yf.samp  <- syf.full[,samp]

## --- CBC
cbc.smooth <- outer(yf.samp, g.samp)
```





