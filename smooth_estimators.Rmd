---
output: html_document
---


## Prelims

```{r packages, warning=FALSE, message=FALSE}
## --- Packages 
library(multitaper)   
library(pbapply)      # Progress bar for apply() functions
library(kableExtra)   
library(itsmr)        # Time series stuff, convenient for ARMA
library(animation)    # For creating gifs
library(fields)       # Supplement for image plots: legends, better colour

## --------- TEMPORARY --------- ##
# load("C:/Users/skyep/Documents/Research/Skyes_Toolbox/splot.RData")
## --------- --------- --------- ##
```

```{r}
# load("Data/AR2_B200_full.RData")
load("Data/UMP_B200_full.RData")
```

---

# GEST \& YEST Previous Methods: SVD

```{r}
# --- Create Function for getting Azadeh's g (and sy)
est.a <- function(sgram, est = "g"){
  # SVD
  duv <- svd(sgram,1,1); gc()
  
  d <- duv$d
  u <- duv$u
  v <- duv$v
  
  # Normalize
  bu <- 1/duv$u[1]
  bv <- duv$d[1]/bu
  
  # Estimate g
  g <- bu * duv$u
  
  # Estimate Sy
  sy <- bv * duv$v
  
  # Return
  return(if(est == "g"){g} else {sy})
}

# normalizing function
normy <- function(x){x/max(abs(x))}
```

### GEST: Estimating g(t)

```{r}
# ALL results
ag.full <- pbapply(trial$bc2, 3, est.a); gc()

# Normalized Average
ag  <- -normy(rowMeans(ag.full))
```

### YEST: Estimating Sy(f)

```{r}
# ALL results
ayf.full <- pbapply(trial$bc2, 3, function(x){est.a(x, est = "sy")}); gc()

# Normalized Average
ayf <- -normy(rowMeans(ayf.full))
```

---

# GEST \& YEST Proposed Method

```{r}
gest <- function(sgram){
  N <- length(sgram[,1])
  A <- outer(1:N,1:N, function(l,j){rowSums(sgram)[l]/rowSums(sgram)[j]})
  G <- Mod(eigen(A/N)$vectors[,1])
  return(G); gc()
}

yest <- function(sgram, normalize = FALSE){
  N <- length(sgram[1,])
  A <- outer(1:NF,1:NF, function(l,j){colSums(sgram)[l]/colSums(sgram)[j]})
  S <- Mod(eigen(A/NF)$vectors[,1])
  if(normalize){S <- S/max(S)}
  return(S); gc()
}
```

### GEST: Estimating g(t)

```{r}
# ALL results
sg.full <- pbapply(trial$bc2, 3, gest); gc()

# Normalized Average
sg  <- normy(rowMeans(ag.full))
```

### YEST: Estimating Sy(f)

```{r}
# ALL results
syf.full <- pbapply(trial$bc2, 3, yest); gc()

# Normalized Average
syf <- normy(rowMeans(syf.full))
```

### Stats [not currently in use]

```{r}
# FULL --- (warning: long-ish runtime)
# g.bc.full  <- pbapply(trial$bc, 3, gest); gc()
# g.cbc.full <- pbapply(trial$cbc,3, gest); gc()
# 
# # STATS
# g.bc1 <- list(mean = pbapply( g.bc.full, 1, mean),
#                 se = pbapply( g.bc.full, 1, sd)/sqrt(M))
# g.cbc1<- list(mean = pbapply(g.cbc.full, 1, mean),
#                 se = pbapply(g.cbc.full, 1, sd)/sqrt(M))
# 
# # Store Confidence Intervals
# g.bc$LCL <- g.bc$mean - 2*g.bc$se
# g.bc$UCL <- g.bc$mean + 2*g.bc$se
# 
# g.cbc$LCL <- g.cbc$mean - 2*g.cbc$se
# g.cbc$UCL <- g.cbc$mean + 2*g.cbc$se
```

```{r save_1}
# save
# gc(); save.image(paste0("Data/gest_",my.type,"_B",B,"_full.RData"))
# 
# # remove trial (large)
# rm(trial)
# 
# # save
# gc(); save.image(paste0("Data/gest_",my.type,"_B",B,"_mini.RData"))
```

### Stats + MTM [better]

```{r}

# Roll Die
set.seed(68); samp <- sample(1:M, 1)

# Time Series for MTM
set.seed(68)
yt <- arima.sim(model = list(ar = c(0.5,-0.5), sd = 10), n = N)

# Spectrum Estimates
yf.mtm <- spec.mtm(yt,plot = FALSE)$spec


# ~~~ 1-BC
  yf.bc1 <- colMeans(trial$bc1[,,samp])

  # Standard Error
  se.bc1 <- apply(trial$bc1[,,samp],2,sd)/sqrt(N)

  # +/- 2*SE
  ucl.bc1 <- yf.bc1+ 2*se.bc1
  lcl.bc1 <- yf.bc1- 2*se.bc1


# ~~~ 2-BC
  yf.bc2 <- colMeans(trial$bc2[,,samp])

  # Standard Error
  se.bc2 <- apply(trial$bc2[,,samp],2,sd)/sqrt(N)

  # +/- 2*SE
  ucl.bc2 <- yf.bc2 + 2*se.bc2
  lcl.bc2 <- yf.bc2 - 2*se.bc2

# SAVE
# rm(trial); gc()
# save.image("Data/AR2_B200_samp.RData")
```

---

# Smooth Spectrograms

```{r}
smoo <- function(g, yf){
  
  # Dimensions for Array
  n  <- length( g[,1])
  nf <- length(yf[,1])
  m  <- length( g[1,])
  
  # Initialize Array
  out <- array(0,c(n,nf,m))
  
  # Smooth each Simulation's Spectrogram
  for(s in 1:m){
    out[,,s] <- outer(g[,m],yf[,m])
  }; gc()
  
  return(out)
}
```

```{r}
# Azadeh's results
asx.full <- smoo(ag.full, ayf.full)
asx <- pbapply( asx.full, 1:2, mean)

# Skye's Results
ssx.full <- smoo(sg.full, syf.full)
ssx <- pbapply( ssx.full, 1:2, mean)

gc()
```

### Single instance

```{r}
# Roll the 100-sided die
samp <- 96

# Choose realizations, get corresponding g
bc2.samp <- trial$bc2[,,samp]
g.samp   <-   sg.full[, samp]
yf.samp  <-  syf.full[, samp]

## --- 2-BC
bc2.smooth <- outer(yf.samp, g.samp)
```

```{r save2}
# save.image(paste0("~/Research/PhD_Proposal/PaperData/",my.type,"_B",B,"_full_S.RData"))
# rm(asx.full, ssx.full); gc()
# save.image(paste0("~/Research/PhD_Proposal/PaperData/",my.type,"_B",B,"_reduced_S.RData"))
```
































































# space















































hi

