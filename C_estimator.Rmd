---
output: html_document
---


## Prelims

```{r packages, warning=FALSE, message=FALSE}
## --- Packages 
library(multitaper)   
library(pbapply)      # Progress bar for apply() functions
library(kableExtra)   
library(itsmr)        # Time series stuff, convenient for ARMA
library(animation)    # For creating gifs
library(fields)       # Supplement for image plots: legends, better colour

## --------- TEMPORARY --------- ##
load("~/Research/Plot_Animations/splot.RData")
## --------- --------- --------- ##
```

---

## Previous Methods: SVD

---

## Proposed Method (NEW)

### Create function

```{r}
gest <- function(sgram){
  N <- length(sgram[,1])
  A <- outer(1:N,1:N, function(l,j){rowSums(sgram)[l]/rowSums(sgram)[j]})
  G <- Mod(eigen(A/N)$vectors[,1])
  G <- G/max(G)
  return(G); gc()
}
```

### Estimating g(t): Based on Mean Results

```{r}
## --- Load Data (choose 1)
load(file = "Data/UMP_B200_mini.RData")       
load(file = "Data/UMP_B200_mini_rev.RData")   
load(file = "Data/UMP_B400_mini_rev.RData")
```

```{r get_c_est}
# Squared Modulating Function
gt <- ct^2

# Stats
g.bc  <- list(mean = gest( bc$mean),
                se = gest( bc$se))
g.cbc <- list(mean = gest(cbc$mean),
                se = gest(cbc$se))

# Store Confidence Intervals
g.bc$LCL <- g.bc$mean - 2*g.bc$se
g.bc$UCL <- g.bc$mean + 2*g.bc$se

g.cbc$LCL <- g.cbc$mean - 2*g.cbc$se
g.cbc$UCL <- g.cbc$mean + 2*g.cbc$se

# save
save.image(paste0("Data/gest_",my.type,"_B",B,"_cheat.RData"))
```

---

### Estimating g(t): Based on ALL Results

```{r}
## --- Load Data (choose 1)
load(file = "Data/AR2_B200_full.RData")       
load(file = "Data/UMP_B200_full.RData")       
load(file = "Data/UMP_B200_full_rev.RData")   
load(file = "Data/UMP_B400_full_rev.RData")
```

```{r}
# Squared Modulating Function
gt <- ct^2

# FULL --- (warning: long-ish runtime)
g.bc.full  <- pbapply(trial$bc, 3, gest); gc()
g.cbc.full <- pbapply(trial$cbc,3, gest); gc()

# STATS
g.bc  <- list(mean = pbapply( g.bc.full, 1, mean),
                se = pbapply( g.bc.full, 1, sd)/sqrt(M))
g.cbc <- list(mean = pbapply(g.cbc.full, 1, mean),
                se = pbapply(g.cbc.full, 1, sd)/sqrt(M))

# Store Confidence Intervals
g.bc$LCL <- g.bc$mean - 2*g.bc$se
g.bc$UCL <- g.bc$mean + 2*g.bc$se

g.cbc$LCL <- g.cbc$mean - 2*g.cbc$se
g.cbc$UCL <- g.cbc$mean + 2*g.cbc$se
```

```{r save_1}
# save
gc(); save.image(paste0("Data/gest_",my.type,"_B",B,"_rev_full.RData"))

# remove trial
rm(trial)

# save
gc(); save.image(paste0("Data/gest_",my.type,"_B",B,"_rev_mini.RData"))
```




# Using g(t) to smooth spectrogram estimates

### Cheating

```{r}
load("Data/gest_UMP_B200_cheat.RData")
```

```{r}
yf.bc <- colMeans(bc$mean)

splot(tru$yf/max(tru$yf), type = "l", lwd = 2)
lines(yf.bc/max(yf.bc), col = "red")


bc.smooth <- outer(yf.bc, g.bc$mean)

par(mfrow = c(1,2))
image.plot(Fs, t, bc.smooth, zlim = range(bc.smooth))
image.plot(Fs, t, t(tru$xtf), zlim = range(tru$xtf))

```


### Not cheating

```{r}
# Load
# load("Data/gest_UMP_B200_mini.RData")
# load("Data/gest_UMP_B200_rev_mini.RData")
load("Data/gest_UMP_B400_rev_mini.RData")

## --- BC
yf.bc <- colMeans(bc$mean)
bc.smooth <- outer(yf.bc, g.bc$mean)

## --- CBC
yf.cbc <- colMeans(cbc$mean)
cbc.smooth <- outer(yf.cbc, g.cbc$mean)

# Save
# save.image("Data/gest_UMP_B200_mini.RData")
# save.image("Data/gest_UMP_B200_rev_mini.RData")
save.image("Data/gest_UMP_B400_rev_mini.RData")
```

```{r}
## --- Sy(f) estimates
# splot(tru$yf/max(tru$yf), type = "l", lwd = 2)
# lines(yf.bc/max(yf.bc), col = "red")

# splot(tru$yf/max(tru$yf), type = "l", lwd = 2)
# lines(yf.cbc/max(yf.cbc), col = "red")

## --- Smoothed SGrams
par(mfrow = c(1,2))
image.plot(Fs, t, bc.smooth, zlim = range(bc.smooth))
image.plot(Fs, t, t(tru$xtf), zlim = range(tru$xtf))

par(mfrow = c(1,2))
image.plot(Fs, t, cbc.smooth, zlim = range(cbc.smooth))
image.plot(Fs, t, t(tru$xtf), zlim = range(tru$xtf))
```

### Single instance: REALLY not cheating

```{r}
# load("Data/gest_UMP_B200_full.RData")
# load("Data/gest_UMP_B200_rev_full.RData")
load("Data/gest_UMP_B400_rev_full.RData")

# Roll the 100-sided die
set.seed(17)
samp <- sample(1:M, 1)

# Choose realizations, get corresponding g
bc.samp  <- trial$bc[,,samp]
gbc.samp <- g.bc.full[,samp]

cbc.samp  <- trial$cbc[,,samp]
gcbc.samp <- g.cbc.full[,samp]

## --- BC
yf.bc <- colMeans(bc.samp)
bc.smooth <- outer(yf.bc, gbc.samp)

## --- CBC
yf.cbc <- colMeans(cbc.samp)
cbc.smooth <- outer(yf.cbc, gcbc.samp)

# save.image("Data/gest_UMP_B200_full.RData")
# save.image("Data/gest_UMP_B200_rev_full.RData")
save.image("Data/gest_UMP_B400_rev_full.RData")
```

```{r}
## --- Sy(f) estimates
# splot(tru$yf/max(tru$yf), type = "l", lwd = 2)
# lines(yf.bc/max(yf.bc), col = "red")

# splot(tru$yf/max(tru$yf), type = "l", lwd = 2)
# lines(yf.cbc/max(yf.cbc), col = "red")

## --- Smoothed SGrams
par(mfrow = c(1,2))
image.plot(Fs, t, bc.smooth, zlim = range(bc.smooth))
image.plot(Fs, t, t(tru$xtf), zlim = range(tru$xtf))

par(mfrow = c(1,2))
image.plot(Fs, t, cbc.smooth, zlim = range(cbc.smooth))
image.plot(Fs, t, t(tru$xtf), zlim = range(tru$xtf))
```

```{r}
# --- No smoothing
par(mfrow = c(1,2))
image.plot(Fs, t,  t(bc.samp), zlim = range( bc.samp))
image.plot(Fs, t, t(cbc.samp), zlim = range(cbc.samp))
```











































### Return to Spectrogram

```{r f_domain}
# control
ct.bc  <- rowSums(bc$mean)/rowSums(bc$mean)[1]
ct.cbc <- rowSums(cbc$mean)/rowSums(cbc$mean)[1]

# True vals
yt <- arima.sim(model = list(ar = c(0.8,-0.4), sd = 100), n = N)
xt <- ct*yt

# Estimated AR(2)
yt.bc.control  <- xt/ct.bc
yt.cbc.control <- xt/ct.cbc

yt.bc  <- xt/(C.bc+1)   # +1 in denominator so that it's positive
yt.cbc <- xt/(C.cbc+1)  # not rigorous just desperate

# estimated spectra of S(f)
yf.mtm <- spec.mtm(ts(yt), plot = FALSE)$spec

yf.bc.control  <- spec.mtm(ts(yt.bc.control) , plot = FALSE)$spec
yf.cbc.control <- spec.mtm(ts(yt.cbc.control), plot = FALSE)$spec

yf.bc.con.scale  <- spec.mtm(ts(yt.bc.control) , plot = FALSE)$spec   / 1e1
yf.cbc.con.scale <- spec.mtm(ts(yt.cbc.control), plot = FALSE)$spec   / 1e1

yf.bc  <- spec.mtm(ts(yt.bc) , plot = FALSE)$spec
yf.cbc <- spec.mtm(ts(yt.cbc), plot = FALSE)$spec

yf.bc.scale  <- spec.mtm(ts(yt.bc) , plot = FALSE)$spec   /2
yf.cbc.scale <- spec.mtm(ts(yt.cbc), plot = FALSE)$spec   /2

limes.control <- range(yf.mtm, yf.bc.control, yf.cbc.control)
limes.con.scale <- range(yf.mtm, yf.bc.con.scale, yf.cbc.con.scale)
limes <- range(yf.mtm, yf.bc, yf.cbc)
limes.scale <- range(yf.mtm, yf.bc.scale, yf.cbc.scale) 

```

```{r, fig.dim = c(12,8), echo = FALSE}

# ---  Plots ------------ ## 
par(mar = c(4,5,4,1))

# -- Control 
splot(Fs, yf.true/1e4, type = "l", colr = skrown$salt, ylim = limes.control)
lines(Fs, yf.mtm)
lines(Fs, yf.bc.control , col = skaturate$blue)
lines(Fs, yf.cbc.control, col = skol$orange)

slab(main = "Spectrum estimates using y = x/c",
     subb = bquote(hat(c)*" is: rowsums, normalized by rowsum at t = 1"),
     xlab = "frequency", ylab = "y(f)")

legend("top", legend = c("BC", "CBC", "mtm"),
        col = c(skaturate$blue, skol$orange, "black"),
       lwd = 2, inset = 0.01)

# -- Control (scaled)
splot(Fs, yf.true/1e4, type = "l", colr = skrown$salt, ylim = limes.con.scale)
lines(Fs, yf.mtm)
lines(Fs, yf.bc.con.scale , col = skaturate$blue)
lines(Fs, yf.cbc.con.scale, col = skol$orange)

slab(main = "Spectrum estimates using y = x/c",
     subb = "rowsums, normalized by rowsum at t = 1, SCALED down (1/10)",
     xlab = "frequency", ylab = "y(f)")

legend("top", legend = c("BC", "CBC", "mtm"),
        col = c(skaturate$blue, skol$orange, "black"),
       lwd = 2, inset = 0.01)

# -- Proposed method
splot(Fs, yf.true/1e4, type = "l", colr = skrown$salt, ylim = limes)
lines(Fs, yf.mtm, col = skrown$B2)
lines(Fs, yf.bc , col = skaturate$blue)
lines(Fs, yf.cbc, col = skol$orange)

slab(main = "Spectrum estimates using y = x/c",
     subb = bquote(hat(c)*" is solution to Ac = 0"),
     xlab = "frequency", ylab = "y(f)")

legend("top", legend = c("BC", "CBC", "mtm"),
        col = c(skaturate$blue, skol$orange, "black"),
       lwd = 2, inset = 0.01)

# -- Proposed method SCALED
splot(Fs, yf.true/1e4, type = "l", colr = skrown$salt, ylim = limes.scale)
lines(Fs, yf.mtm, col = skrown$B2)
lines(Fs, yf.bc.scale , col = skaturate$blue)
lines(Fs, yf.cbc.scale, col = skol$orange)

slab(main = "Spectrum estimates using y = x/c",
     subb = bquote(hat(c)*" is solution to Ac = 0, SCALED down (1/2)"),
     xlab = "frequency", ylab = "y(f)")

legend("top", legend = c("BC", "CBC", "mtm"),
        col = c(skaturate$blue, skol$orange, "black"),
       lwd = 2, inset = 0.01)

```
























```{r animation plot, eval = FALSE, echo = FALSE}
yf.bc  <-  bc$mean/C.bc
yf.cbc <- cbc$mean/C.cbc
yf.n   <-  bc$mean/ct^2


# image.plot(yf.n)
p <- 0
pb <- txtProgressBar(style = 3)

saveGIF({  for (my.t in seq(1,N,by = 5)) {

splot(Fs, yf.true/1e3, type = "l", lwd = 2)
lines(Fs, yf.bc[my.t,], col = "blue")
lines(Fs, yf.cbc[my.t,], col = "goldenrod")

  gc()
    p <- p+1
    setTxtProgressBar(pb, p/500)

    } },
  
  # --- GIF details
  interval   = 0.1,
  movie.name = paste0("~/Plots/test_1.gif"),
  ani.height = 668, ani.width = 1080); gc()
```




























